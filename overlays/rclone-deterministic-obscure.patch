diff --git a/fs/config/obscure/obscure.go b/fs/config/obscure/obscure.go
index 17aae165b..fe634a294 100644
--- a/fs/config/obscure/obscure.go
+++ b/fs/config/obscure/obscure.go
@@ -6,9 +6,7 @@ import (
 	"crypto/cipher"
 	"crypto/rand"
 	"encoding/base64"
-	"errors"
 	"fmt"
-	"io"
 	"log"
 )
 
@@ -47,15 +45,7 @@ func crypt(out, in, iv []byte) error {
 // This is done by encrypting with AES-CTR
 func Obscure(x string) (string, error) {
 	plaintext := []byte(x)
-	ciphertext := make([]byte, aes.BlockSize+len(plaintext))
-	iv := ciphertext[:aes.BlockSize]
-	if _, err := io.ReadFull(cryptRand, iv); err != nil {
-		return "", fmt.Errorf("failed to read iv: %w", err)
-	}
-	if err := crypt(ciphertext[aes.BlockSize:], plaintext, iv); err != nil {
-		return "", fmt.Errorf("encrypt failed: %w", err)
-	}
-	return base64.RawURLEncoding.EncodeToString(ciphertext), nil
+	return base64.RawURLEncoding.EncodeToString(plaintext), nil
 }
 
 // MustObscure obscures a value, exiting with a fatal error if it failed
@@ -73,15 +63,19 @@ func Reveal(x string) (string, error) {
 	if err != nil {
 		return "", fmt.Errorf("base64 decode failed when revealing password - is it obscured?: %w", err)
 	}
-	if len(ciphertext) < aes.BlockSize {
-		return "", errors.New("input too short when revealing password - is it obscured?")
-	}
-	buf := ciphertext[aes.BlockSize:]
-	iv := ciphertext[:aes.BlockSize]
-	if err := crypt(buf, buf, iv); err != nil {
-		return "", fmt.Errorf("decrypt failed when revealing password - is it obscured?: %w", err)
+	return string(tryDecrypt(ciphertext)), nil
+}
+
+// Try to decrypt for backwards compatibility
+func tryDecrypt(ciphertext []byte) []byte {
+	if len(ciphertext) >= aes.BlockSize {
+		buf := ciphertext[aes.BlockSize:]
+		iv := ciphertext[:aes.BlockSize]
+		if err := crypt(buf, buf, iv); err == nil {
+			return buf
+		}
 	}
-	return string(buf), nil
+	return ciphertext
 }
 
 // MustReveal reveals an obscured value, exiting with a fatal error if it failed
