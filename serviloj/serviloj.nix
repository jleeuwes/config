{
	# Inspiration taken from https://github.com/nh2/nixops-tutorial/blob/master/example-nginx-deployment.nix

	network.description = "Our humble all-encompassing serviloj deployment";
	network.enableRollback = true; # no idea what this does
	
	servilo-1 = { config, nodes, lib, ... }: {
		imports = [ ./modules/tilaa_vps.nix ];

		deployment.targetHost = "servilo-1.tilaa.cloud";
		
		deployment.keys = {
			"radstand.wolk.admin" = {
				destDir = "/run/ujoslosiloj/radstand/wolk";
				keyFile = ./secrets.temp/radstand.wolk.admin;
				user = "nextcloud-radstand";
			};
		};
		
		# The rest is a configuration just like nixos/configuration.nix
		# TODO put database(s) on the machine itself and share them between containers
		
		services.openssh.enable = true;
		users.users = {
			root = {
				passwordFile = "/root/password"; # must be present on the machine
				openssh.authorizedKeys.keyFiles = [
					../scarif/home/jeroen/.ssh/id_rsa.pub
				];
			};

			# Make sure users created in the different containers
			# also exist on the machine (actually, in our whole deployment), with a fixed uid.
			# That way files and processes look good both within and outside the container;
			# most importantly files in stokado will have recognizable and consistent owners.
			# Note that the username outside the container is more precise than inside the containers;
			# this way we can differentiate different customers outside the container,
			# while default service usernames can still be used inside containers.
			# TODO also fix groups
			# Warning: changing uids here after a user has been created has no effect!
			# You have to destroy and rebuild the container,
			# or go inside the container, rm /var/lib/nixos/uid-map and userdel the user,
			# then fiddle to reactivate the container
			nextcloud-radstand = {
				uid = 70000;
			};
			redmine-radstand = {
				uid = 70001;
			};
			mysql-radstand = {
				uid = 70002;
			};
			nginx-radstand = {
				uid = 70003;
			};
		};

		networking = {
			hostName = "servilo-1";
			firewall = {
				allowPing = true;
				# port 80 is only allowed for Let's Encrypt challenges
				allowedTCPPorts = [ 22 80 443 ];
			};
			nat = {
				enable = true;
				internalInterfaces = [ "ve-+" ];
				externalInterface  = "ens3";
			};
		};

		services.fail2ban.enable = true;

		security.acme = {
			acceptTerms = true;
			# I'm guessing the rest of the cert config is autogenerated
			# due to the nginx config.
			certs."roodmijn.radstand.nl".email = "jeroen@lwstn.eu";
			certs."volgendewolk.radstand.nl".email = "jeroen@lwstn.eu";
		};

		services.nginx = {
			enable = true;
			recommendedGzipSettings = true;
			recommendedOptimisation = true;
			recommendedProxySettings = true;
			recommendedTlsSettings = true;

			virtualHosts = {
				"roodmijn.radstand.nl" = {
					forceSSL = true;
					enableACME = true;
					locations."/".proxyPass = "http://${config.containers.roodmijn.localAddress}:3000";
				};
				"volgendewolk.radstand.nl" = {
					forceSSL = true;
					enableACME = true;
					locations."/".proxyPass = "http://${config.containers.wolk.localAddress}";
				};
			};
		};

		# NOTE: to destroy a container,
		# you have to remove/rename it here and deploy,
		# then nixos-container destroy $containername (this doesn't seem to do much, so not sure if necessary)
		# then chattr -i /var/lib/containers/$containername/var/empty
		# and then rm -rf /var/lib/containers/$containername
		containers = {
			roodmijn = {
				autoStart = true;
				privateNetwork = true;
				localAddress = "10.0.0.1";
				hostAddress  = "10.0.1.1";

				config = { pkgs, ... }: {
					imports = [ ./modules/container.nix ];

					users.users.redmine.uid = lib.mkForce nodes.servilo-1.config.users.users.redmine-radstand.uid;
					users.users.mysql.uid = lib.mkForce nodes.servilo-1.config.users.users.mysql-radstand.uid;

					networking.firewall = {
						allowPing = true;
						allowedTCPPorts = [ 3000 ];
					};
					
					services.redmine.enable = true;
				};
			};

			wolk = {
				autoStart = true;
				privateNetwork = true;
				localAddress = "10.0.0.2";
				hostAddress  = "10.0.1.2";
				bindMounts = {
					"/var/local/stokado/radstand/wolk" = {
						# hostPath: customer/app/service
						hostPath = "/var/local/stokado/radstand/wolk";
						isReadOnly = false;
					};
					"/run/ujoslosiloj/radstand/wolk" = {
						hostPath = "/run/ujoslosiloj/radstand/wolk";
						isReadOnly = true;
					};
				};

				config = { pkgs, ...}: {
					imports = [ ./modules/container.nix ];
					
					users.users.nextcloud.uid = nodes.servilo-1.config.users.users.nextcloud-radstand.uid;
					users.users.nginx.uid = lib.mkForce nodes.servilo-1.config.users.users.nginx-radstand.uid;

					networking.firewall = {
						allowPing = true;
						allowedTCPPorts = [ 80 ];
					};

					services.nextcloud = {
						# TODO take relevant php/nextcloud config from current
						# manual installation

						enable = true;

						# This attribute exists in a newer NixOS version
						# package = pkgs.nextcloud18;

						home = "/var/local/stokado/radstand/wolk/nextcloud";

						autoUpdateApps = {
							enable = true;
						};

						# when it works, we can replace wolk.radstand.nl
						hostName = "volgendewolk.radstand.nl";
						https = true; # no idea how this relates to config.overwriteProtocol

						maxUploadSize = "512M";

						# Okay, so our real nginx is running outside of the
						# container, but the nextcloud module generates
						# useful nginx config if we enable it here;
						# so we might run more nginx instances than necessary
						# (although if this is disabled I'm not sure what server
						# would run nextcloud...)
						nginx.enable = true;

						config = {
							adminuser = "admin";
							adminpassFile = "/run/ujoslosiloj/radstand/wolk/radstand.wolk.admin";
							
							dbtype = "sqlite"; # let's start simple
							
							overwriteProtocol = "https";
						};
					};
				};
			};
		};
	};
}
