#!/usr/bin/env bash

set -Eeu
set -o pipefail

set -o noclobber

# We rely on tools in PATH.
# We should really make a package out of this.
CMD_GPG=gpg2
# CMD_HTPASSWD=$(nix-build --no-out-link --attr apacheHttpd '<nixpkgs>')/bin/htpasswd

# Identity to sign with and to always encrypt for:
ME=jeroen@lwstn.eu

# if ! type -P "$CMD_GPG" > /dev/null; then
# 	echo "Ja, hallo, ik kan $CMD_GPG niet vinden." >&2
# 	exit 1
# fi

main() {
	local command
	if test $# -eq 0; then
		command=""
	else
		command="$1"
		shift
	fi

	case "$command" in
	get-exact)
		# get-exact is a bit of a misnomer: it will not show the exact password
		# all it did was not append a newline
		printf '`%q get-exact` is deprecated; use `%q cat -n` instead.\n' "$0" "$0" >&2
		do_show plain -n -- "$@"
	;;
	show|cat)
		do_show plain "$@"
	;;
	hash)
		# output passwords in /etc/shadow-like format
		do_show hashed "$@"
	;;
	add|new)
		file="$1"
		shift
		if [ -e "$file" ]; then
		  echo "Wachtwoord $file bestaat al." >&2
		  exit 1
		fi
		
		local recipients=(--recipient "$ME")
		for recipient in "$@"; do
			echo "Wachtwoord zal ook leesbaar zijn voor $recipient" >&2
			recipients+=(--recipient "$recipient")
		done
		
		local pass=""
		if tty -s; then
			# If terminal; ask for a one line password
			stty -echo
			read -r -p "Wachtwoord: " pass
			stty echo
		else
			# Otherwise, read full input
			pass=$(cat)
		fi
		if [ -z "$pass" ]; then
			echo "Geen wachtwoord gegeven." >&2
			exit 1
		fi
		local content
		# We don't redirect the command to $file directly so no empty file will be created on error
		content=$(printf "%s" "$pass" | $CMD_GPG --batch --use-agent --armor --encrypt --sign --local-user "$ME" "${recipients[@]}")
		printf "%s" "$content" > "$file"
		echo "Wachtwoord $file opgeslagen." >&2
	;;
	*)
		echo "Onbekend commando '$command'. Tot ziens!" >&2
		exit 1
	;;
	esac
}

do_show() {
	local cmd="$1"
	shift
	local success=0
	local seen=0
	local prefix=""
	local content
	local suppress_last_newline=no
	while [ $# -ge 1 ]; do
		case "$1" in
		-n)
			suppress_last_newline=yes
			shift
		;;
		--)
			shift
			break
		;;
		-*)
			echo "Unrecognized option: $1" >&2
			exit 1
		;;
		*)
			break
		;;
		esac
	done
	if [ $# -eq 0 ]; then
		echo "Reading from stdin..." >&2
		set -- -
	fi
	if [ $# -gt 1 ]; then
		cmd=show_"$cmd"_multi
	else
		cmd=show_"$cmd"_single
	fi
	for file in "$@"; do
		# We let gpg produce any errors for us and use && to make sure we continue with the other files in case of an error
		content=$($CMD_GPG --use-agent --batch --decrypt -- "$file") && {
			if [ $success -gt 0 ]; then
				# This approach gives a messy combination of stdout and stderr,
				# but it does make sure we never put empty lines on stdout.
				printf '\n'
			fi
			"$cmd" "$file" "$content"
			let ++success # ++ first because of weird exit code if expression is 0
		}
	done
	if [ "$suppress_last_newline" = no -a $success -gt 0 ]; then
		printf '\n'
	fi
	if [ $success -lt $# ]; then
		exit 1
	fi
}

show_plain_single() {
	printf "%s" "$2"
}
show_plain_multi() {
	printf "%s: %s" "$1" "$2"
}
show_hashed_single() {
	printf '%s' "$2" | mkpasswd --stdin --method=sha512crypt | tr -d %'\n'
	# Alternative using Apache's htpasswd, which uses bcrypt which is more
	# robust against offline brute-forcing, but does not seem to be supported
	# for use in /etc/shadow
	# printf '%s' "$2" | "$CMD_HTPASSWD" -niB "$1" | cut -d: -f2 | tr -d $'\n'
}
show_hashed_multi() {
	printf "%s: " "$1"
	printf '%s' "$2" | mkpasswd --stdin --method=sha512crypt | tr -d $'\n'
	# Alternative using Apache's htpasswd (see above)
	# printf '%s' "$2" | "$CMD_HTPASSWD" -niB "$1" | tr -d $'\n'
}


main "$@"
